"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[507],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>f});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),c=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return a.createElement(s.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(t),d=r,f=m["".concat(s,".").concat(d)]||m[d]||u[d]||i;return t?a.createElement(f,o(o({ref:n},p),{},{components:t})):a.createElement(f,o({ref:n},p))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6712:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=t(7462),r=(t(7294),t(3905));const i={sidebar_position:20},o="Additional Notes",l={unversionedId:"Additional Notes",id:"Additional Notes",title:"Additional Notes",description:"Thinking in alpha values",source:"@site/docs/Additional Notes.md",sourceDirName:".",slug:"/Additional Notes",permalink:"/roact-spring/docs/Additional Notes",draft:!1,editUrl:"https://github.com/chriscerie/roact-spring/edit/master/docs/Additional Notes.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{sidebar_position:20},sidebar:"defaultSidebar",previous:{title:"Controller",permalink:"/roact-spring/docs/Additional Classes/controller"},next:{title:"Migrating",permalink:"/roact-spring/docs/Migrating"}},s={},c=[{value:"Thinking in alpha values",id:"thinking-in-alpha-values",level:2},{value:"Using different springs for each element",id:"using-different-springs-for-each-element",level:3},{value:"Using alpha values",id:"using-alpha-values",level:3}],p={toc:c},m="wrapper";function u(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"additional-notes"},"Additional Notes"),(0,r.kt)("h2",{id:"thinking-in-alpha-values"},"Thinking in alpha values"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"roact-spring")," supports animating many different data types. However, sometimes it may be more convenient to animate from 0 to 1 and subscribe elements to it so they can interpolate between different values themselves. This is especially helpful when you want to subscribe multiple elements with different values to a single spring."),(0,r.kt)("p",null,"This is also helpful to ensure different elements that you want to animate together will truly stay together. You don't run the risk of animating some elements but forgetting to animate others."),(0,r.kt)("p",null,"One downside to this approach is that it's only convenient when elements are animating along a line between only 2 points. If you want to animate among arbitrary positions, using the relevant data type directly is more appropriate."),(0,r.kt)("h3",{id:"using-different-springs-for-each-element"},"Using different springs for each element"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function Example(_)\n    local styles, api = RoactSpring.useSpring(function()\n        return {\n            position1 = UDim2.fromScale(0.2, 0.2),\n            position2 = UDim2.fromScale(0.1, 0.8),\n            position3 = UDim2.fromScale(0.6, 0.4),\n        }\n    end)\n\n    React.useEffect(function()\n        -- We need to call `api.start` for each value\n        api.start({ position1 = UDim2.fromScale(0.8, 0.2) })\n        api.start({ position2 = UDim2.fromScale(0.2, 0.6) })\n        api.start({ position3 = UDim2.fromScale(0.5, 0.9) })\n    end, {})\n\n    return React.createElement(React.Fragment, nil, {\n        Frame1 = React.createElement("Frame", {\n            Position = styles.position1,\n        }),\n        Frame2 = React.createElement("Frame", {\n            Position = styles.position2,\n        }),\n        Frame3 = React.createElement("Frame", {\n            Position = styles.position3,\n        }),\n    })\nend\n')),(0,r.kt)("h3",{id:"using-alpha-values"},"Using alpha values"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local function Example(_)\n    local styles, api = RoactSpring.useSpring(function()\n        return {\n            alpha = 0,\n        }\n    end)\n\n    React.useEffect(function()\n        -- We only have to call `api.start` once\n        api.start({ alpha = 1 })\n    end, {})\n\n    return React.createElement(React.Fragment, nil, {\n        Frame1 = React.createElement("Frame", {\n            Position = styles.position:map(function(alpha)\n                return UDim2.fromScale(0.2, 0.2):Lerp(UDim2.fromScale(0.8, 0.2), alpha)\n            end),\n        }),\n        Frame2 = React.createElement("Frame", {\n            Position = styles.position:map(function(alpha)\n                return UDim2.fromScale(0.1, 0.8):Lerp(UDim2.fromScale(0.2, 0.6), alpha)\n            end),\n        }),\n        Frame3 = React.createElement("Frame", {\n            Position = styles.position:map(function(alpha)\n                return UDim2.fromScale(0.6, 0.4):Lerp(UDim2.fromScale(0.5, 0.9), alpha)\n            end),\n        }),\n    })\nend\n')))}u.isMDXComponent=!0}}]);